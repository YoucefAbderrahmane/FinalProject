/*
 * MyNSGA.cpp
 *
 *  Created on: 12 juil. 2016
 *      Author: root
 */

#include "MyNSGA.h"

MyNSGA::MyNSGA() {
	// TODO Auto-generated constructor stub

}

MyNSGA::~MyNSGA() {
	// TODO Auto-generated destructor stub
}


chromosome MyNSGA::tournamentSelection(int individu1, int individu2, population *p)
{
	if(p->get_individual(individu1).pareto_rank < p->get_individual(individu2).pareto_rank) return p->get_individual(individu1);
	if(p->get_individual(individu1).pareto_rank > p->get_individual(individu2).pareto_rank) return p->get_individual(individu2);
	if(p->get_individual(individu1).crowding_dist > p->get_individual(individu2).crowding_dist) return p->get_individual(individu1);
	if(p->get_individual(individu1).crowding_dist < p->get_individual(individu2).crowding_dist) return p->get_individual(individu2);
	if(p->get_individual(individu1).violation_ratio < p->get_individual(individu2).violation_ratio) return p->get_individual(individu1);
	if(p->get_individual(individu1).violation_ratio > p->get_individual(individu2).violation_ratio) return p->get_individual(individu2);
	return ((rand()/RAND_MAX) < 0.5 ?  p->get_individual(individu1) : p->get_individual(individu2));
}

void MyNSGA::crossover(chromosome enf1, chromosome enf2, chromosome p1, chromosome p2)
{
	if(rand()/RAND_MAX < 0.5)
	{
		int size = p1.genes.size();
		if(rand()/RAND_MAX < 1/3){// one point crossover

			int i = rand() % size;//make sur to have at least one gene changed
			int k =0;
			for(k =0; k < i; k++)
			{
				enf1.genes.push_back(p1.genes[k]);
				enf2.genes.push_back(p2.genes[k]);
				enf1.observations.push_back(p1.observations[k]);
				enf2.observations.push_back(p2.observations[k]);
				enf1.telescopes_alloc.push_back(p1.telescopes_alloc[k]);
				enf2.telescopes_alloc.push_back(p2.telescopes_alloc[k]);
			}
			for(k=1; k< min; k++)
			{
				enf1.genes.push_back(p2.genes[k]);
				enf2.genes.push_back(p1.genes[k]);
				enf1.observations.push_back(p1.observations[k]);
				enf2.observations.push_back(p2.observations[k]);
				enf1.telescopes_alloc.push_back(p1.telescopes_alloc[k]);
				enf2.telescopes_alloc.push_back(p2.telescopes_alloc[k]);
			}


		}
		if(1/3 < rand()/RAND_MAX < 2/3)//uniform crossover
		{

		}
		if( rand()/RAND_MAX < 1)
		{

		}
	}
	}

void MyNSGA::mutation()
{}

void MyNSGA::nsga2(population *p)
{
	int NP = p->get_size();
	std::vector<int> v1(NP), v2(NP);
	chromosome parent1, parent2, enfant1, enfant2;
	for(int i=0;i < NP; i++)
	{
		v1[i] = i;
		v2[i] = i;
	}
	for(int g =0; g< this->nb_gen; g++)
	{
		p->update_pareto_information(); // update fronts and ranks
		p->updateViolation();
		population  cr(p->getIndividuals(),p->get_size()); //Initialization de R
		std::random_shuffle(v1.begin(),v1.end()); //shuffle the vectors to pick the parents randomly
		std::random_shuffle(v2.begin(),v2.end());
		//unsigned seed = std::

		for(int i =0; i < NP; i+=4)
		{
			parent1 = tournamentSelection(v1[i],v1[i+1],*p);
			parent2 = tournamentSelection(v1[i+2],v1[i+3],*p);
			crossover(enfant1,enfant2,parent1,parent2);
			mutation();
			//maj des fitness contrainte et dom
			enfant1.compute_obj_func();
			enfant2.compute_obj_func();
			enfant1.updateViolationRatio();
			enfant2.updateViolationRatio();
			cr.addIndividual(enfant1);
			cr.update_dom(cr.get_size()-1);
			cr.addIndividual(enfant2);
			cr.update_dom(cr.get_size()-1);

			parent1 = tournamentSelection(v2[i],v2[i+1],*p);
			parent2 = tournamentSelection(v2[i+2],v2[i+3],*p);
			crossover(enfant1,enfant2,parent1,parent2);
			mutation();
			//p->update_dom(enfant1);
			//maj des fitness contrainte et dom
			enfant1.compute_obj_func();
			enfant2.compute_obj_func();
			enfant1.updateViolationRatio();
			enfant2.updateViolationRatio();
			cr.addIndividual(enfant1);
			cr.update_dom(cr.get_size()-1);
			cr.addIndividual(enfant2);
			cr.update_dom(cr.get_size()-1);
		}
		//trier et choisir les meilleurs -> pareto information + tri + sÃ©lectionnner les NP premier
		cr.bestIndividuals(NP);
		p->setIndividuals(cr.getIndividuals());
	}
}
